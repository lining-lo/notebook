## 0.1 + 0.2 !== 0.3？

在 JavaScript 中，`0.1 + 0.2 !== 0.3` 这一现象源于计算机对浮点数的二进制表示方式，是所有遵循 **IEEE 754 标准**的编程语言（如 JavaScript、Java、Python 等）共有的问题，而非 JavaScript 特有的 bug。

**1.原因解析**

（1）十进制转二进制的精度丢失
十进制小数 `0.1` 和 `0.2` 无法被二进制精确表示，就像十进制无法精确表示 `1/3`（`0.333...`）一样。

- `0.1` 的二进制表示是无限循环小数：`0.0001100110011...₂`
- `0.2` 的二进制表示是无限循环小数：`0.0011001100110...₂`

（2）IEEE 754 双精度 64 位浮点数
JavaScript 的 `number` 类型使用 64 位存储，其中：

- 1 位符号位
- 11 位指数位
- 52 位尾数位（有效数字）

无限循环的二进制小数会被截断为 52 位，导致精度丢失。

**2.计算过程演示**

（1）二进制加法
截断后的 `0.1` 和 `0.2` 相加，结果为：

```plaintext
0.0001100110011001100110011001100110011001100110011010₂
```

转换为十进制约等于：

```plaintext
0.3000000000000000444089209850062616169452667236328125
```

（2）与 `0.3` 的二进制比较
`0.3` 的二进制同样被截断，实际存储值约为：

```plaintext
0.299999999999999988897769753748434595763683319091796875
```

因此，`0.1 + 0.2` 的结果与 `0.3` 的存储值存在微小差异，导致 `0.1 + 0.2 !== 0.3`。

**3.验证方法**

（1）直接比较

```javascript
console.log(0.1 + 0.2 === 0.3); // false
```

（2）查看具体值

```javascript
console.log(0.1 + 0.2); // 0.30000000000000004
```

（3）检查差值

```javascript
console.log((0.1 + 0.2) - 0.3); // 5.551115123125783e-17
```

**4.解决方案**

（1）使用误差范围（epsilon）比较
比较时允许一个极小的误差范围（如 `Number.EPSILON`）：

```javascript
function nearlyEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

console.log(nearlyEqual(0.1 + 0.2, 0.3)); // true
```

（2）定点数运算
将小数转换为整数计算，避免浮点数精度问题：

```javascript
console.log((0.1 * 10 + 0.2 * 10) / 10 === 0.3); // true
```

（3）使用 `toFixed()` 格式化结果
适用于需要显示固定位数小数的场景：

```javascript
console.log((0.1 + 0.2).toFixed(2) === "0.30"); // true
```

（4）第三方库
如 `decimal.js`、`big.js` 等，提供任意精度计算：

```javascript
const Decimal = require('decimal.js');
console.log(
  new Decimal(0.1).add(0.2).equals(new Decimal(0.3)) // true
);
```

**5.何时需要担心？**

- 金融计算：必须使用定点数或专用库（如 `decimal.js`）。
- 高精度科学计算：需要控制误差范围。
- 用户界面显示：使用 `toFixed()` 格式化结果。

日常开发中，简单计算通常无需特殊处理，但需避免直接比较浮点数是否相等。

**6.其他语言的类似问题**

这并非 JavaScript 独有，其他语言也存在相同问题：

```python
# Python
print(0.1 + 0.2 == 0.3)  # False

# Java
System.out.println(0.1 + 0.2 == 0.3);  // false
```


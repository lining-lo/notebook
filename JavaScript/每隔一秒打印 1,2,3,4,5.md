# 每隔一秒打印 1,2,3,4,5

## 实现方式

下面为你介绍几种在 JavaScript 里实现每隔一秒依次打印 1 到 5 的方法。

### 方法一：使用 `for` 循环搭配 `let` 关键字

```javascript
for (let i = 1; i <= 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, i * 1000);
}
```

**原理剖析**：`let` 具备块级作用域特性，在每次循环迭代时都会创建一个新的变量副本，所以每个定时器都能获取到正确的 `i` 值。

### 方法二：利用立即执行函数表达式（IIFE）结合 `var` 关键字

```javascript
for (var i = 1; i <= 5; i++) {
  (function (num) {
    setTimeout(() => {
      console.log(num);
    }, num * 1000);
  })(i);
}
```

**原理剖析**：借助立即执行函数，把当前的 `i` 值通过参数传递给内部函数，进而避免闭包问题。

### 方法三：采用 `async/await` 和 `for` 循环

```javascript
async function printNumbers() {
  for (let i = 1; i <= 5; i++) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log(i);
  }
}

printNumbers();
```

**原理剖析**：借助 `await` 暂停循环的执行，直到定时器完成，从而实现每秒打印一个数字的效果。

### 方法四：运用 `Array.from` 和 `forEach`

```javascript
Array.from({ length: 5 }, (_, i) => i + 1).forEach(num => {
  setTimeout(() => {
    console.log(num);
  }, num * 1000);
});
```

**原理剖析**：先创建一个包含 1 到 5 的数组，然后针对每个元素设置定时器，保证按顺序每秒打印一个数字。

### 方法五：使用递归调用

```javascript
function printNumber(n) {
  if (n > 5) return;
  setTimeout(() => {
    console.log(n);
    printNumber(n + 1);
  }, 1000);
}

printNumber(1);
```

**原理剖析**：在定时器的回调函数里递归调用自身，每秒钟递增数字并进行打印。

上述所有方法都能达成每隔一秒依次打印 1 到 5 的效果，你可以根据实际的应用场景来挑选最为合适的实现方式。

## var 为什么不行

```javascript
for (let i = 1; i <= 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, i * 1000);
}
```

这段代码借助 `for` 循环和 `setTimeout` 实现了每秒打印一个递增数字的功能。下面来详细分析其运行机制和关键特性：

### 核心运行机制

1. **循环流程**：循环从 `i=1` 开始，每完成一次迭代 `i` 就增加 1，直到 `i>5` 时停止。
2. **定时器设定**：在每次循环迭代中，都会创建一个 `setTimeout`，其延迟时间为 `i * 1000` 毫秒，也就是 `i` 秒。
3. **闭包的作用**：`setTimeout` 的回调函数形成了一个闭包，它捕获了当前迭代的 `i` 值。
4. **异步执行**：所有的定时器都是异步执行的。当主线程完成循环后，才会按照延迟时间的顺序依次触发定时器的回调函数。

### 关键特性解析

- **块级作用域**：由于使用了 `let` 声明变量，`i` 具有块级作用域。这意味着在每次循环迭代时，`i` 都会被绑定到一个新的变量上。
- **变量副本机制**：每次迭代所创建的定时器回调函数，都会捕获当前迭代的 `i` 值。所以，当定时器触发时，就能输出正确的数字。
- **延迟时间规律**：每个定时器的延迟时间按照 `i` 的值依次递增，即分别为 1 秒、2 秒、3 秒、4 秒、5 秒，从而实现了每秒打印一个数字的效果。

### 输出结果演示

```plaintext
1（1秒后）
2（2秒后）
3（3秒后）
4（4秒后）
5（5秒后）
```

### 为什么 `let` 能正常工作

如果把 `let` 换成 `var`，代码的执行结果就会不一样。因为 `var` 声明的变量不具备块级作用域，在整个函数作用域内都有效。所有的定时器回调函数捕获的都是同一个 `i` 变量，而当定时器触发时，循环已经结束，此时 `i` 的值为 6。

### 对比实验

下面是使用 `var` 的错误示例：

```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(() => {
    console.log(i); // 会输出 5 次 6
  }, i * 1000);
}
```

### 总结

- **`let` 的优势**：利用块级作用域和变量副本机制，确保每个定时器都能获取到正确的 `i` 值。
- **异步执行特性**：定时器会在循环结束后，按照各自设定的延迟时间依次执行。
- **闭包的影响**：闭包捕获变量的当前值，而非变量未来的变化值。

这种实现方式简洁高效，是在 JavaScript 中实现定时序列操作的经典方法。